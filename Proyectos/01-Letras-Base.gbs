//--------------------------------
// REQUIERE 00-Gobstones-Base.gbs
//--------------------------------

//--------------------------------
//--------------------------------
// INTERFAZ de 01-Letras-Base.gbs
//--------------------------------
//--------------------------------

//--------------------------------
// Definiciones de tipos
//--------------------------------
type Letra is variant { 
   case Espacio {} 
   case A {}    case B {}    case C {}    case D {}    case E {}    case F {}    case G {}    case H {}    case I {}    
   case J {}    case K {}    case L {}    case M {}    case N {}    case Ñ {}    case O {}    case P {}    case Q {}
   case R {}    case S {}    case T {}    case U {}    case V {}    case W {}    case X {}    case Y {}    case Z {} 
}

//--------------------------------
// Operaciones de creación de letras (interfaz)
//--------------------------------

///*@ATTRIBUTE@tooltip@Denota una letra*/
///*@ATTRIBUTE@block_name@_@*/
///*@ATTRIBUTE@block_dropdown@[(" ", 'Espacio'), ("A", 'A'), ("B", 'B'), ("C", 'C'), ("D", 'D'), ("E", 'E'), ("F", 'F'), ("G", 'G'), ("H", 'H'), ("I", 'I'), ("J", 'J'), ("K", 'K'), ("L", 'L'), ("M", 'M'), ("N", 'N'), ("Ñ", 'Ñ'), ("O", 'O'), ("P", 'P'), ("Q", 'Q'), ("R", 'R'), ("S", 'S'), ("T", 'T'), ("U", 'U'), ("V", 'V'), ("W", 'W'), ("X", 'X'), ("Y", 'Y'), ("Z", 'Z')]@*/
//function letra_(letra) { return(letra) }

function letra_(códigoDeLetra) { return(aux_letraParaElCódigo(códigoDeLetra)) }

//--------------------------------
// Operaciones de acceso a letras (interfaz)
//--------------------------------

/*@ATTRIBUTE@block_name@_ está antes que _@*/
function esMenorLetra__(letra1, letra2) { return(aux_esMenorLetra(letra1, letra2)) }

/*@ATTRIBUTE@block_name@la letra más chica@*/
function minLetra() { return(aux_minLetra()) }

/*@ATTRIBUTE@block_name@la letra más grande@*/
function maxLetra() { return(aux_maxLetra()) }

/*@ATTRIBUTE@block_name@letra siguiente a _@*/
function letraSiguiente_(letra) { return(aux_letraSiguiente(letra)) }

/*@ATTRIBUTE@block_name@letra previa a _@*/
function letraPrevia_(letra) { return(aux_letraPrevia(letra)) }

//--------------------------------
// Operaciones de E/S de letras (interfaz)
//--------------------------------
function hayLetra() { return(aux_hayLetra()) }

function  leerLetra()        { return(aux_leerLetra()) }
procedure PonerLetra_(letra) { AuxPonerLetra(letra)    }
procedure SacarLetraActual() { AuxSacarLetraActual()   }
//--------------------------------
//--------------------------------
// FIN INTERFAZ de 01-Letras-Base.gbs
//--------------------------------
//--------------------------------

//--------------------------------
//--------------------------------
// AUXILIARES de 01-Letras-Base.gbs
//--------------------------------
//--------------------------------

//--------------------------------
// Auxiliares para acceso a letras
//--------------------------------
function aux_esMenorLetra(letra1, letra2) {
    return (aux_códigoParaLaLetra(letra1) < aux_códigoParaLaLetra(letra2))
}

function aux_minLetra() { return (aux_letraParaElCódigo(aux_minCódigoDeLetra()) }
function aux_maxLetra() { return (aux_letraParaElCódigo(aux_maxCódigoDeLetra())) }

function aux_letraSiguiente(letra) {
   return (choose 
            aux_minLetra() when (letra == Z)
            aux_letraParaElCódigo(aux_códigoParaLaLetra(letra)+1) otherwise
          )
}

function aux_letraPrevia(letra) {
   return (choose 
            aux_maxLetra() when (letra == aux_minLetra())
            aux_letraParaElCódigo(aux_códigoParaLaLetra(letra)-1) otherwise
          )
}

//--------------------------------
// Auxiliares para sensar letras en el tablero
//--------------------------------
function aux_hayLetra() { return (aux_hayTipoLetra() && aux_hayDatoLetra()) }

//--------------------------------
// Operaciones de E/S de letras
//--------------------------------
function aux_leerLetra() {
  // PRECONDICIÓN: hay una letra en la celda actual
  if (not aux_hayLetra())      { BOOM("No hay una letra que pueda leer") }
  return(aux_letraParaElCódigo(aux_leerDato()))
}         

procedure AuxPonerLetra(letra) {
  AuxSacarTodas()
  AuxPonerRepresentaciónDeLetra(letra)
}

procedure AuxSacarLetraActual() {
  // PRECONDICIÓN: hay una letra en la celda actual
  if (not(aux_hayLetra())) { BOOM("No hay una letra que sacar") }
  AuxSacarRepresentaciónDeLetra()
}


//--------------------------------
// Operaciones auxiliares de codificación
//--------------------------------
function aux_códigoParaElTipoLetra()      { return(2)                            }
function aux_códigoParaElDatoLetra(letra) { return(aux_códigoParaLaLetra(letra)) }

function aux_hayTipoLetra()      { return (aux_esTipoLetra(aux_leerTipo())) }
function aux_hayDatoLetra()      { return (aux_esDatoLetra(aux_leerDato())) }

function aux_esTipoLetra(código) { return (código == aux_códigoParaElTipoLetra())                            }
function aux_esDatoLetra(dato)   { return (dato >= aux_minCódigoDeLetra() && dato <= aux_maxCódigoDeLetra()) }

function aux_minCódigoDeLetra() { return(10) }
function aux_maxCódigoDeLetra() { return(37) }

function aux_códigoParaLaLetra(letra) {
  return (choose
    10 when (letra == Espacio)
    11 when (letra == A)
    12 when (letra == B)
    13 when (letra == C)
    14 when (letra == D)
    15 when (letra == E)
    16 when (letra == F)
    17 when (letra == G)
    18 when (letra == H)
    19 when (letra == I)
    20 when (letra == J)
    21 when (letra == K)
    22 when (letra == L)
    23 when (letra == M)
    24 when (letra == N)
    25 when (letra == Ñ)
    26 when (letra == O)
    27 when (letra == P)
    28 when (letra == Q)
    29 when (letra == R)
    30 when (letra == S)
    31 when (letra == T)
    32 when (letra == U)
    33 when (letra == V)
    34 when (letra == W)
    35 when (letra == X)
    36 when (letra == Y)
    37 when (letra == Z)
    boom("Al extender las letras, deberías extender también las funciones de codificación") otherwise
    )
}

function aux_letraParaElCódigo(códigoDeLetra) {
  return (choose
    Espacio when (códigoDeLetra == 10)
    A       when (códigoDeLetra == 11)
    B       when (códigoDeLetra == 12)
    C       when (códigoDeLetra == 13)
    D       when (códigoDeLetra == 14)
    E       when (códigoDeLetra == 15)
    F       when (códigoDeLetra == 16)
    G       when (códigoDeLetra == 17)
    H       when (códigoDeLetra == 18)
    I       when (códigoDeLetra == 19)
    J       when (códigoDeLetra == 20)
    K       when (códigoDeLetra == 21)
    L       when (códigoDeLetra == 22)
    M       when (códigoDeLetra == 23)
    N       when (códigoDeLetra == 24)
    Ñ       when (códigoDeLetra == 25)
    O       when (códigoDeLetra == 26)
    P       when (códigoDeLetra == 27)
    Q       when (códigoDeLetra == 28)
    R       when (códigoDeLetra == 29)
    S       when (códigoDeLetra == 30)
    T       when (códigoDeLetra == 31)
    U       when (códigoDeLetra == 32)
    V       when (códigoDeLetra == 33)
    W       when (códigoDeLetra == 34)
    X       when (códigoDeLetra == 35)
    Y       when (códigoDeLetra == 36)
    Z       when (códigoDeLetra == 37)
    boom("No es un código de letra") otherwise
    )
}

procedure AuxPonerRepresentaciónDeLetra(letra) {
  AuxPoner__Veces(aux_colorParaElTipo(), aux_códigoParaElTipoLetra())
  AuxPoner__Veces(aux_colorParaElDato(), aux_códigoParaLaLetra(letra))
}

procedure AuxSacarRepresentaciónDeLetra() {
  // PRECONDICIÓN: hay una letra en la celda actual
  AuxSacarTodas()
}
//--------------------------------
//--------------------------------
// AUXILIARES de 01-Letras-Base.gbs
//--------------------------------
//--------------------------------
