interactive program {
  K_ARROW_LEFT  -> { MoverseHacia(Oeste)     }
  K_ARROW_RIGHT -> { MoverseHacia(Este)      }
  K_ARROW_UP    -> { MoverseHacia(Norte)     }
  K_ARROW_DOWN  -> { MoverseHacia(Sur)       }
  K_ENTER       -> { ProcesarLaCartaActual() }
}

procedure MoverseHacia(dir) {
    if (hayDosCartasDestapadas()) { TaparAmbasCartasDestapadas() }
    PasarASiguienteCartaHacia_(dir)
}

procedure ProcesarLaCartaActual() {
  DestaparLaCartaActualSiSePuede()
  IluminarLasCartasDestapasSiCorresponde()
}

function hayDosCartasDestapadas() {
  return (hayCartaDestapadaSinIluminar() 
       && hayOtraCartaDestapadaSinIluminar())
}

procedure IluminarLasCartasDestapasSiCorresponde() {
  if (hayDosCartasDestapadas() && lasCartasDestapadasSonIguales())
    { IluminarAmbasCartasDestapadas() } 
}

procedure DestaparLaCartaActualSiSePuede() { if (hayCartaTapada()) { DestaparCartaActual() } }

procedure IluminarAmbasCartasDestapadas() {
  // Primero la lejana, para que la última en procesar sea la inicial
  IrALaCartaOtraCartaDestapada()
  IluminarCartaActual()
  IrALaCartaOtraCartaDestapada()
  IluminarCartaActual()
  // Termina posicionado sobre la carta inicial
}

procedure TaparAmbasCartasDestapadas() {
  // Primero la lejana, para que la última en procesar sea la inicial
  IrALaCartaOtraCartaDestapada()
  TaparCartaActual()
  IrALaCartaOtraCartaDestapada()
  TaparCartaActual()
  // Termina posicionado sobre la carta inicial
}

procedure IrALaCartaOtraCartaDestapada() {
  PasarASiguienteCarta()
  while (not hayCartaDestapadaSinIluminar()) { PasarASiguienteCarta() }
}

function lasCartasDestapadasSonIguales() {
  primeraCarta := leerCarta()
  IrALaCartaOtraCartaDestapada()
  segundaCarta := leerCarta()
  return (lasCartasSonIguales(primeraCarta, segundaCarta))
}

function lasCartasSonIguales(primeraCartaAControlar, segundaCartaACotrolar) {
  return (valor(primeraCartaAControlar) == valor(segundaCartaACotrolar)
       && palo(primeraCartaAControlar)  == palo(segundaCartaACotrolar)
         )
}
